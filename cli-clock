#!/bin/bash


DIGIT_COLOR=RED
COLON_COLOR=YELLOW


BLACK=0 RED=1 GREEN=2 YELLOW=3 BLUE=4 MAGENTA=5 CYAN=6 WHITE=7
DC="\e[3${!DIGIT_COLOR};4${!DIGIT_COLOR}m" CC="\e[3${!COLON_COLOR};4${!COLON_COLOR}m" NC="\e[m"

NUM[${#NUM[@]}]="######|##__##|##__##|##__##|######"
NUM[${#NUM[@]}]="____##|____##|____##|____##|____##"
NUM[${#NUM[@]}]="######|____##|######|##____|######"
NUM[${#NUM[@]}]="######|____##|######|____##|######"
NUM[${#NUM[@]}]="##__##|##__##|######|____##|____##"
NUM[${#NUM[@]}]="######|##____|######|____##|######"
NUM[${#NUM[@]}]="######|##____|######|##__##|######"
NUM[${#NUM[@]}]="######|____##|____##|____##|____##"
NUM[${#NUM[@]}]="######|##__##|######|##__##|######"
NUM[${#NUM[@]}]="######|##__##|######|____##|____##"
COLON="__|::|__|::|__"
SPACE_WIDTH=2
NUM_WIDTH=$(awk -F\| '{ print length($1) }' <<<${NUM[0]})
COLON_WIDTH=$(awk -F\| '{ print length($1) }' <<<${COLON})
WIDTH=$(( NUM_WIDTH * 6 + COLON_WIDTH * 2 + SPACE_WIDTH * 7 ))
HEIGHT=$(awk -F\| '{ print NF }' <<<${COLON})
CLOCKCOUNT=4

FLAG24H=I
if [[ $1 == "--24hour" ]]; then
	FLAG24H=H
	shift
fi

function show_time {
	ARGC=$#

	# get time
	if [[ $ARGC == 0 ]]; then
		# no arguments, do local
		time=$(
			while read -sn1 char; do
				printf "${char} "
			done <<<$(date "+%${FLAG24H}:%M:%S %Z")
		)
	else
		ZONEARG=$1
		time=$(
			while read -sn1 char; do
				printf "${char} "
			done <<<$(TZ=$ZONEARG date "+%${FLAG24H}:%M:%S %Z")
		)
	fi

	# print out each character
	for (( y=1; ${y} <= ${HEIGHT}; y++ )); do
		for char in ${time}; do
			case ${char} in
				[0-9])
					string="${NUM[${char}]}"
				;;

				[:])
					string="${COLON}"
				;;
				*)
					string="${char}"
				;;
			esac
			printf "  $(cut -f ${y} -d '|' <<<${string} | sed "s/\(#\+\)/\\${DC}\1/g ; \
									s/\(:\+\)/\\${CC}\1/g ; \
									s/\(_\+\)/\\${NC}\1/g ; \
									s/_/ /g")${NC}"
		done && [[ ${y} != ${HEIGHT} ]] && echo
	done

	echo "" ; echo ""
}

<<<<<<< HEAD
while sleep ${delay:-0}; do
=======
while sleep .1; do

	if [[ ${SECONDS} == ${seconds_log} ]]; then
		continue
	else
		# track seconds
		seconds_log=${SECONDS}

		# determine screen size
		dimensions=$(
			tput -S <<-!
				lines
				cols
			!
		)
		lines=${dimensions%%$'\x0a'*}
		cols=${dimensions##*$'\x0a'}

		# clear for new dimensions
		if [[ ${dimensions} != ${dimensions_log} ]]; then
			dimensions_log=${dimensions}
			clear
		fi
>>>>>>> 2c0a7370373d735fd7c5a26f0cc928a6aeee0d68

	# determine terminal size
	dimensions=$(
		tput -S <<-!
<<<<<<< HEAD
			lines
			cols
=======
			cup $(( ( lines - HEIGHT * CLOCKCOUNT ) / 2 )) 0
			civis
>>>>>>> 2c0a7370373d735fd7c5a26f0cc928a6aeee0d68
		!
	)
	# '\x0a' is a newline character
	lines=${dimensions%%$'\n'*}
	cols=${dimensions##*$'\n'}

<<<<<<< HEAD
	# redraw screen if terminal dimensions change
	if [[ ${dimensions} != ${dimensions_log} ]]; then
		dimensions_log=${dimensions}
		clear
		unset time_log
=======
		show_time # local
		show_time "America/New_York"
		show_time GMT
		show_time 'Asia/Singapore'

		[[ $1 == "--hide-cursor" ]] || tput -S <<-!
			cup ${lines} ${cols}
			cnorm
		!
>>>>>>> 2c0a7370373d735fd7c5a26f0cc928a6aeee0d68
	fi

	# put the cursor in the correct position to center the clock in the terminal
	tput -S <<-!
		cup $(( (lines-HEIGHT)/2 )) $(( (cols-WIDTH)/2 ))
		civis
	!

	# initialize date-reading loop
	unset forward_movement
	time_cur=$(date +%I:%M:%S)
	for (( i=0; ${i}<${#time_cur}; i++ )); do

		char_cur=${time_cur:${i}:1}
		char_log=${time_log:${i}:1}

		case ${char_cur} in
			[0-9])
				string=${NUM[${char_cur}]}
				char_width=${NUM_WIDTH}
			;;

			:)
				string=${COLON}
				char_width=${COLON_WIDTH}
			;;
		esac

		# if the character has changed, redraw it! 
		if [[ ${char_cur} != ${char_log} ]]; then
			[[ ${forward_movement} ]] && tput cuf ${forward_movement}
			unset forward_movement
			for (( y=1; ${y}<=${HEIGHT}; y++ )); do
				segment=$(cut -f ${y} -d '|' <<<${string})
				segment=$(sed "s/\(#\+\)/\\${DC}\1/g;\
					    s/\(:\+\)/\\${CC}\1/g;\
					    s/\(_\+\)/\\${NC}\1/g;\
					    s/_/ /g" <<<${segment}${NC})

				tput sc
				printf "${segment}"
				tput -S <<-!
					rc
					cud 1
				!
			done
			tput cuu ${HEIGHT}
		fi

		(( forward_movement+=${char_width} ))
		if [[ ${i} -lt $(( ${#time_cur} - 1 )) ]]; then
			(( forward_movement+=${SPACE_WIDTH} ))
		fi

	done
	time_log=${time_cur}

	[[ $1 == "--hide-cursor" ]] || tput -S <<-!
		cup ${lines} 0 
		cnorm
	!

	# determine how long to sleep before the next update
	nanoseconds=10#$(date +%N)
	delay=0.$(( 1000000000 - ${nanoseconds} ))

done
