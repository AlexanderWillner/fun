#!/bin/bash


DIGIT_COLOR=RED
LETTER_COLOR=YELLOW
COLON_COLOR=YELLOW

TIMEZONES="America/New_York Europe/London Asia/Baghdad Asia/Singapore Asia/Tokyo"

BLACK=0 RED=1 GREEN=2 YELLOW=3 BLUE=4 MAGENTA=5 CYAN=6 WHITE=7
DC="\e[3${!DIGIT_COLOR};4${!DIGIT_COLOR}m"
LC="\e[3${!LETTER_COLOR};4${!LETTER_COLOR}m"
CC="\e[3${!COLON_COLOR};4${!COLON_COLOR}m"
NC="\e[m"

NUM[0]="######|##__##|##__##|##__##|######"
NUM[1]="____##|____##|____##|____##|____##"
NUM[2]="######|____##|######|##____|######"
NUM[3]="######|____##|######|____##|######"
NUM[4]="##__##|##__##|######|____##|____##"
NUM[5]="######|##____|######|____##|######"
NUM[6]="######|##____|######|##__##|######"
NUM[7]="######|____##|____##|____##|____##"
NUM[8]="######|##__##|######|##__##|######"
NUM[9]="######|##__##|######|____##|____##"
A="_AAAA_|AA__AA|AAAAAA|AA__AA|AA__AA"
B="AAAAA_|AA__AA|AAAAA_|AA__AA|AAAAAA"
C="_AAAA_|AA__AA|AA____|AA__AA|_AAAA_"
D="AAAAA_|AA__AA|AA__AA|AA__AA|AAAAA_"
E="AAAAAA|AA____|AAAAAA|AA____|AAAAAA"
F="AAAAAA|AA____|AAAA__|AA____|AA____"
G="_AAAA_|AA____|AA_AAA|AA__AA|_AAAA_"
H="AA__AA|AA__AA|AAAAAA|AA__AA|AA__AA"
I="AAAA|_AA_|_AA_|_AA_|AAAA"
J="___AAA|____AA|____AA|AA__AA|_AAAA_"
K="AA__AA|AA_AA_|AAAA__|AA_AA_|AA__AA"
L="AA____|AA____|AA____|AA____|AAAAAA"
M="AA___AA|AAA_AAA|AAAAAAA|AA_A_AA|AA___AA"
N="AA__AA|AAA_AA|AAAAAA|AA_AAA|AA__AA"
O="_AAAA_|AA__AA|AA__AA|AA__AA|_AAAA_"
P="AAAAAA|AA__AA|AAAAAA|AA____|AA____"
Q="_AAAA_|AA__AA|AA__AA|AA_AAA|_AAAA_"
R="AAAAA_|AA__AA|AAAAAA|AA_AA_|AA__AA"
S="_AAAAA|AA____|_AAAA_|____AA|AAAAA_"
T="AAAAAA|__AA__|__AA__|__AA__|__AA__"
U="AA__AA|AA__AA|AA__AA|AA__AA|_AAAA_"
V="AA__AA|AA__AA|AA__AA|_AAAA_|__AA__"
W="AA___AA|AA_A_AA|AAAAAAA|AAA_AAA|AA___AA"
X="AA__AA|_AAAA_|__AA__|_AAAA_|AA__AA"
Y="AA__AA|AA__AA|_AAAA_|__AA__|__AA__"
Z="AAAAAA|___AA_|__AA__|_AA___|AAAAAA"
COLON="__|::|__|::|__"
COMMA="__|__|__|::|_:"
EXCLEMATION="::|::|::|__|::"
PERIOD="__|__|__|__|::"
SEMICOLON="__|::|__|::|_:"
SPACE="__|__|__|__|__"
NEWLINE="NEWLINE"
SPACE_WIDTH=2
LINE_HEIGHT=$(awk -F\| '{ print NF }' <<<${COLON})
LOCAL_TIMEZONE=$(awk -F'"' '/ZONE=/ { print $2 }' /etc/sysconfig/clock)

screenSetup() {
	# determine terminal size
	dimensions=$(
		tput -S <<-!
			lines
			cols
		!
	)
	lines=${dimensions%%$'\n'*}
	cols=${dimensions##*$'\n'}

	# redraw screen if terminal dimensions change or key pressed
	if [[ ${dimensions} != ${dimensions_log} ]]; then
		dimensions_log=${dimensions}
		clear
	fi

	# put the cursor in the correct position to center the clock in the terminal
	start_row=$(( (lines-HEIGHT)/2 ))
	start_col=$(( (cols-WIDTH)/2 ))
	start_row=2
	start_col=$(( ${SPACE_WIDTH} + 1 ))
	tput civis
	vert_offset=0
	unset char_log
	printf "\E[$((${start_row}+${vert_offset}));${start_col}f"
	space_on_line=$(( cols - start_col ))
}

drawChar() {
	local string="$1"

	#deciper string
        case ${string} in
                [a-z])  string=${string^^};;
                :)      string=COLON;;
                ,)      string=COMMA;;
                !)      string=EXCLEMATION;;
                .)      string=PERIOD;;
                \;)     string=SEMICOLON;;
                ' ')    string=SPACE;;
                $'\n')  string=NEWLINE;;
        esac
        if [[ ${string} =~ [0-9] ]]; then
                string=${NUM[${string}]}
        else
                string=${!string}
        fi
        char_width=${string%%|*}
        char_width=${#char_width}
	newlines=${string//[^|]}
	newlines=${#newlines}

	# newline check
	if [[ ${char_width} -gt ${space_on_line} || ${string} == "NEWLINE" ]]; then
		(( vert_offset+=$(( LINE_HEIGHT + 1 )) ))
		printf "\E[$(( ${start_row} + ${vert_offset} ));${start_col}f"
		space_on_line=$(( cols - start_col ))
		[[ ${string} == "NEWLINE" ]] && return
	fi

	# apply formatting
	string=${string//#/${DC}#}
	string=${string//A/${LC}A}
	string=${string//:/${CC}:}
	string=${string//_/${NC} }

	# load string into array, one element per row
	local IFS_OLD="${IFS}"
	local IFS='|'
	local i
	for i in ${string}; do
		local segments[${#segments[@]}]=${i}
	done
	IFS=${IFS_OLD}

	# print the character
	for (( i=0; ${i} <= ${#segments[@]}; i++ )); do
		segment=${segments[${i}]}${NC}
		printf "${segment}"
		# for all but the last line, move the cursor left and down
		if [[ ${i} -lt ${newlines} ]]; then
			printf "\E[${char_width}D\E[1B"
		fi
	done
	# after the last line, move cursor right and up to prepare for next character
	printf "\E[${SPACE_WIDTH}C\E[${newlines}A"
	# keep track of remaining space on the current line
	(( space_on_line-=$(( ${char_width} + ${SPACE_WIDTH} )) ))
}

printString() {
	local string="${@}"
	while [[ ${string} ]]; do
		# print the first character in ${string}
		local char="${string:0:1}"
		drawChar "${char}"
		# remove the character we printed from ${string}
		string=${string:1}
	done
}

getDate() {
	for i in ${LOCAL_TIMEZONE} ${@}; do
		TZ=${i} date +"%H:%M:%S %Z"
	done
}

end() {
	# put cursor below any output, make it visibile, and exit
	printf "\n%.s" $(eval echo {0..${LINE_HEIGHT}})
	tput cvvis
	exit
}

trap end SIGHUP SIGINT SIGTERM

#while sleep ${delay:-0}; do
while sleep ${delay:-0}; do

	screenSetup

	date="$(getDate ${TIMEZONES})"

	printString "${@:-${date}}"
	[[ ${@} ]] && end

	# determine how long to sleep before the next update
	nanoseconds=10#$(date +%N)
	delay=0.$(( 1000000000 - ${nanoseconds} ))

done
